use std::ops::Index;

use bns_core::{Chunk, ChunkPos};
use bns_rng::{FromRng, Rng};

use bytemuck::{Contiguous, Zeroable};
use glam::{IVec2, IVec3};

use crate::biomemap::Climate;
use crate::column_gen::ColumnGen;
use crate::structure::StructureRegistry;
use crate::GenCtx;

/// A unique identifier for the biomes generated by the standard world generator.
#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, Contiguous)]
#[repr(u8)]
pub enum BiomeId {
    Plains = 0,
    OakForest,
    Desert,
    PineForest,
    Ocean,
}

// SAFETY:
//  0 is the value of BiomeId::Plains.
unsafe impl Zeroable for BiomeId {}

impl BiomeId {
    /// The total number of [`BiomeId`] instances.
    pub const COUNT: usize = <Self as Contiguous>::MAX_VALUE as usize + 1;

    /// Returns an iterator over all possible [`BiomeId`]s.
    pub fn iter_all() -> impl Clone + ExactSizeIterator<Item = Self> {
        (0..Self::COUNT as u8).map(|x| unsafe { std::mem::transmute(x) })
    }
}

/// Stores information about a particular biome.
pub struct BiomeInfo {
    /// The allowed continentality range for the biome.
    pub continentality_range: (f32, f32),
    /// The allowed temperature range for the biome.
    pub temperature_range: (f32, f32),
    /// The allowed humidity range for the biome.
    pub humidity_range: (f32, f32),
    /// A weight value used to determine how likely the biome is to spawn compared to the other
    /// biomes.
    pub weight: u32,
    /// The maximum size of the structures that can be spawn in the biome. This is how far
    /// the [`register_structures`] function will be called from the biome's location.
    ///
    /// This is measured in chunks.
    ///
    /// [`register_structures`]: Biome::register_structures
    pub max_structure_size: IVec3,
    /// The [`Biome`] implementation associated with the biome.
    pub implementation: Box<dyn Biome>,
}

impl BiomeInfo {
    /// Returns whether the provided [`Climate`] is allowed to spawn in a biome with this
    /// [`BiomeInfo`].
    pub fn is_climate_allowed(&self, climate: &Climate) -> bool {
        self.continentality_range.0 <= climate.continentality
            && climate.continentality <= self.continentality_range.1
            && self.temperature_range.0 <= climate.temperature
            && climate.temperature <= self.temperature_range.1
            && self.humidity_range.0 <= climate.humidity
            && climate.humidity <= self.humidity_range.1
    }
}

/// The interface that's provided to biomes to generate new chunks.
pub trait Biome: FromRng + Send + Sync {
    /// Returns the height value of the biome at the provided position.
    fn height(&self, pos: IVec2) -> f32;

    /// Place the base blocks of the biome in the provided chunk.
    ///
    /// This function is expected to only place blocks that are part of the biome itself
    /// (potentially by checking the biome values in `column`). Additionally, this function
    /// is expected to losely follow the heightmap generated for the column.
    fn build(&self, pos: ChunkPos, column: &ColumnGen, ctx: &GenCtx, chunk: &mut Chunk);

    /// Registers the structures that should be spawned in the provided chunk.
    fn register_structures(
        &self,
        pos: ChunkPos,
        column: &ColumnGen,
        ctx: &GenCtx,
        structures: &mut StructureRegistry,
    );

    /// Prints debug information about itself in the provided buffer.
    fn debug_info(&self, w: &mut dyn std::fmt::Write, pos: IVec3) -> std::fmt::Result;
}

/// The registry of all available biomes.
pub struct BiomeRegistry {
    biomes: [BiomeInfo; BiomeId::COUNT],
}

impl FromRng for BiomeRegistry {
    fn from_rng(rng: &mut impl Rng) -> Self {
        Self {
            biomes: [
                // Plains
                BiomeInfo {
                    continentality_range: (0.0, 1.0),
                    temperature_range: (-1.0, 1.0),
                    humidity_range: (-1.0, 1.0),
                    weight: 200,
                    max_structure_size: IVec3::ONE,
                    implementation: Box::new(crate::biomes::Plains::from_rng(rng)),
                },
                // OakForest
                BiomeInfo {
                    continentality_range: (0.0, 1.0),
                    temperature_range: (-1.0, 1.0),
                    humidity_range: (-1.0, 1.0),
                    weight: 100,
                    max_structure_size: IVec3::ONE,
                    implementation: Box::new(crate::biomes::OakForest::from_rng(rng)),
                },
                // Desert
                BiomeInfo {
                    continentality_range: (0.0, 1.0),
                    temperature_range: (-1.0, 1.0),
                    humidity_range: (-1.0, 1.0),
                    weight: 100,
                    max_structure_size: IVec3::ZERO,
                    implementation: Box::new(crate::biomes::Desert::from_rng(rng)),
                },
                // PineForest
                BiomeInfo {
                    continentality_range: (0.0, 1.0),
                    temperature_range: (-1.0, 1.0),
                    humidity_range: (-1.0, 1.0),
                    weight: 50,
                    max_structure_size: IVec3::ZERO,
                    implementation: Box::new(crate::biomes::PineForest::from_rng(rng)),
                },
                // Ocean
                BiomeInfo {
                    continentality_range: (-1.0, 0.0),
                    temperature_range: (-1.0, 1.0),
                    humidity_range: (-1.0, 1.0),
                    weight: 200,
                    max_structure_size: IVec3::ZERO,
                    implementation: Box::new(crate::biomes::Ocean::from_rng(rng)),
                },
            ],
        }
    }
}

impl Index<BiomeId> for BiomeRegistry {
    type Output = BiomeInfo;

    #[inline(always)]
    fn index(&self, index: BiomeId) -> &Self::Output {
        unsafe { self.biomes.get_unchecked(index as usize) }
    }
}
